#!/usr/bin/env python3
# Generated By: Cursor (Claude Sonnet 4.5)

import unittest
from unittest.mock import Mock, patch

from gh_pulls_summary.main import RateLimitError, github_api_request


class TestRateLimitRetry(unittest.TestCase):
    """Test rate limit retry logic in github_api_request."""

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_single_retry_success(self, mock_get, mock_time, mock_sleep):
        """Test successful retry after rate limit is hit once."""
        # Set up current time
        mock_time.return_value = 1000

        # First response: rate limited (will retry)
        rate_limit_response = Mock()
        rate_limit_response.status_code = 403
        rate_limit_response.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1060",  # 60 seconds from now
        }

        # Second response: success
        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {"result": "success"}

        mock_get.side_effect = [rate_limit_response, success_response]

        # Call the function
        result = github_api_request("/test/endpoint", use_paging=False)

        # Verify the result
        self.assertEqual(result, {"result": "success"})

        # Verify sleep was called with correct duration (60 + 1 buffer)
        mock_sleep.assert_called_once_with(61)

        # Verify two requests were made
        self.assertEqual(mock_get.call_count, 2)

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_multiple_retries_success(self, mock_get, mock_time, mock_sleep):
        """Test successful retry after multiple rate limits."""
        # Set up current time
        mock_time.return_value = 1000

        # First response: rate limited
        rate_limit_response_1 = Mock()
        rate_limit_response_1.status_code = 403
        rate_limit_response_1.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1030",  # 30 seconds from now
        }

        # Second response: still rate limited
        rate_limit_response_2 = Mock()
        rate_limit_response_2.status_code = 403
        rate_limit_response_2.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1045",  # 45 seconds from now
        }

        # Third response: success
        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {"result": "success"}

        mock_get.side_effect = [
            rate_limit_response_1,
            rate_limit_response_2,
            success_response,
        ]

        # Call the function
        result = github_api_request("/test/endpoint", use_paging=False)

        # Verify the result
        self.assertEqual(result, {"result": "success"})

        # Verify sleep was called twice with correct durations
        self.assertEqual(mock_sleep.call_count, 2)
        # First sleep: 30 + 1 = 31 seconds
        # Second sleep: 45 + 1 = 46 seconds
        self.assertEqual(mock_sleep.call_args_list[0][0][0], 31)
        self.assertEqual(mock_sleep.call_args_list[1][0][0], 46)

        # Verify three requests were made
        self.assertEqual(mock_get.call_count, 3)

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_max_retries_exceeded(self, mock_get, mock_time, mock_sleep):
        """Test that RateLimitError is raised after max retries."""
        # Set up current time
        mock_time.return_value = 1000

        # All responses: rate limited
        rate_limit_response = Mock()
        rate_limit_response.status_code = 403
        rate_limit_response.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1060",
        }

        mock_get.return_value = rate_limit_response

        # Call the function with max_retries=3 (default)
        with self.assertRaises(RateLimitError) as ctx:
            github_api_request("/test/endpoint", use_paging=False)

        # Verify error message
        self.assertIn("after 3 retries", str(ctx.exception))
        self.assertIn("1060", str(ctx.exception))

        # Verify sleep was called 3 times (for 3 retry attempts)
        self.assertEqual(mock_sleep.call_count, 3)

        # Verify 4 requests were made (initial + 3 retries)
        self.assertEqual(mock_get.call_count, 4)

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_wait_time_calculation(self, mock_get, mock_time, mock_sleep):
        """Test that wait time is correctly calculated from reset timestamp."""
        # Current time: 1000
        # Reset time: 1234
        # Expected wait: 1234 - 1000 + 1 = 235 seconds
        mock_time.return_value = 1000

        rate_limit_response = Mock()
        rate_limit_response.status_code = 403
        rate_limit_response.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1234",
        }

        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {"data": "test"}

        mock_get.side_effect = [rate_limit_response, success_response]

        _ = github_api_request("/test/endpoint", use_paging=False)

        # Verify correct wait time
        mock_sleep.assert_called_once_with(235)

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_minimum_wait_time(self, mock_get, mock_time, mock_sleep):
        """Test that minimum wait time is enforced even if reset is in past."""
        # Current time: 1000
        # Reset time: 900 (in the past)
        # Expected wait: max(900 - 1000 + 1, 1) = 1 second (minimum)
        mock_time.return_value = 1000

        rate_limit_response = Mock()
        rate_limit_response.status_code = 403
        rate_limit_response.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "900",  # In the past
        }

        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {"data": "test"}

        mock_get.side_effect = [rate_limit_response, success_response]

        _ = github_api_request("/test/endpoint", use_paging=False)

        # Verify minimum wait time of 1 second
        mock_sleep.assert_called_once_with(1)

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_no_retry_on_non_rate_limit_403(self, mock_get, mock_time, mock_sleep):
        """Test that 403 without rate limit headers doesn't trigger retry."""
        mock_time.return_value = 1000

        # 403 but not a rate limit (missing headers)
        forbidden_response = Mock()
        forbidden_response.status_code = 403
        forbidden_response.headers = {}  # No rate limit headers
        forbidden_response.text = "Forbidden"

        mock_get.return_value = forbidden_response

        # Should raise GitHubAPIError, not retry
        from gh_pulls_summary.main import GitHubAPIError

        with self.assertRaises(GitHubAPIError):
            github_api_request("/test/endpoint", use_paging=False)

        # Verify no sleep was called (no retry)
        mock_sleep.assert_not_called()

        # Verify only one request was made (no retry)
        mock_get.assert_called_once()

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_no_retry_on_403_with_nonzero_remaining(
        self, mock_get, mock_time, mock_sleep
    ):
        """Test that 403 with remaining quota doesn't trigger retry."""
        mock_time.return_value = 1000

        # 403 but remaining quota is not zero
        response = Mock()
        response.status_code = 403
        response.headers = {
            "X-RateLimit-Remaining": "10",  # Still has quota
            "X-RateLimit-Reset": "1060",
        }
        response.text = "Forbidden for other reason"

        mock_get.return_value = response

        # Should raise GitHubAPIError, not retry
        from gh_pulls_summary.main import GitHubAPIError

        with self.assertRaises(GitHubAPIError):
            github_api_request("/test/endpoint", use_paging=False)

        # Verify no sleep was called (no retry)
        mock_sleep.assert_not_called()

        # Verify only one request was made (no retry)
        mock_get.assert_called_once()

    @patch("gh_pulls_summary.main.logging.warning")
    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_retry_logging(
        self, mock_get, mock_time, mock_sleep, mock_logging
    ):
        """Test that proper logging occurs during retry."""
        mock_time.return_value = 1000

        rate_limit_response = Mock()
        rate_limit_response.status_code = 403
        rate_limit_response.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1060",
        }

        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {"data": "test"}

        mock_get.side_effect = [rate_limit_response, success_response]

        _ = github_api_request("/test/endpoint", use_paging=False)

        # Verify logging was called
        mock_logging.assert_called_once()
        log_message = mock_logging.call_args[0][0]

        # Verify log contains key information
        self.assertIn("Rate limit exceeded", log_message)
        self.assertIn("Current time: 1000", log_message)
        self.assertIn("Reset time: 1060", log_message)
        self.assertIn("Wait duration: 61 seconds", log_message)
        self.assertIn("(retry 1/3)", log_message)

    @patch("gh_pulls_summary.main.time.sleep")
    @patch("gh_pulls_summary.main.time.time")
    @patch("gh_pulls_summary.main.requests.get")
    def test_rate_limit_with_pagination(self, mock_get, mock_time, mock_sleep):
        """Test rate limit retry works correctly with pagination."""
        mock_time.return_value = 1000

        # First page: rate limited
        rate_limit_response = Mock()
        rate_limit_response.status_code = 403
        rate_limit_response.headers = {
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1030",
        }

        # Second page: success with data
        success_response_1 = Mock()
        success_response_1.status_code = 200
        success_response_1.json.return_value = [{"id": 1}, {"id": 2}]

        # Third page: empty (end of pagination)
        success_response_2 = Mock()
        success_response_2.status_code = 200
        success_response_2.json.return_value = []

        mock_get.side_effect = [
            rate_limit_response,
            success_response_1,
            success_response_2,
        ]

        result = github_api_request("/test/endpoint", use_paging=True)

        # Verify pagination worked after retry
        self.assertEqual(result, [{"id": 1}, {"id": 2}])

        # Verify sleep was called once
        mock_sleep.assert_called_once_with(31)

        # Verify three requests were made
        self.assertEqual(mock_get.call_count, 3)


if __name__ == "__main__":
    unittest.main()
