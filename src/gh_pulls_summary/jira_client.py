#!/usr/bin/env python3
# Generated By: Cursor (Claude Sonnet 4.5)
"""
JIRA Client - REST API client for JIRA interactions
Minimal implementation focused on fetching issue metadata and rank information.
"""

import logging
import os
from typing import Any, cast
from urllib.parse import urljoin

import requests


class JiraClientError(Exception):
    """Base exception for JIRA client errors."""


class JiraAuthenticationError(JiraClientError):
    """Raised when JIRA authentication fails."""


class JiraClient:
    """
    JIRA API client for fetching issue metadata and rank information.

    This client is specifically designed to fetch:
    - Issue type (Feature, Initiative, Outcome, etc.)
    - Rank field value (customfield_12311940 or discovered)
    - Basic issue details
    """

    def __init__(
        self,
        base_url: str | None = None,
        token: str | None = None,
        rank_field_id: str | None = None,
    ):
        """
        Initialize JIRA client.

        Args:
            base_url: JIRA instance URL (can also be set via JIRA_BASE_URL env var)
            token: API token for authentication (can also be set via JIRA_TOKEN env var)
            rank_field_id: Explicit Rank field ID (e.g., 'customfield_12311940'). If not provided, will attempt discovery.

        Raises:
            ValueError: If required configuration is missing
        """
        base_url_value = base_url or os.getenv("JIRA_BASE_URL") or ""
        self.base_url = base_url_value.rstrip("/")
        self.token = token or os.getenv("JIRA_TOKEN")

        if not self.base_url:
            raise ValueError(
                "JIRA base URL is required. Set via --jira-url or JIRA_BASE_URL environment variable."
            )

        if not self.token:
            raise ValueError(
                "JIRA token is required. Set via --jira-token or JIRA_TOKEN environment variable."
            )

        self.api_base = urljoin(self.base_url, "/rest/api/2/")
        self.session = requests.Session()

        # Set up Bearer token authentication
        self.session.headers.update({"Authorization": f"Bearer {self.token}"})

        # Set common headers
        self.session.headers.update(
            {"Content-Type": "application/json", "Accept": "application/json"}
        )

        # Use explicit rank field ID or cache for lazy discovery
        if rank_field_id:
            logging.info(f"Using explicit JIRA Rank field: {rank_field_id}")
        self._rank_field_id: str | None = rank_field_id if rank_field_id else None

    def _make_request(
        self,
        endpoint: str,
        params: dict[str, Any] | None = None,
        resource_name: str = "resource",
    ) -> Any:
        """
        Make an API request with centralized error handling.

        Args:
            endpoint: API endpoint path (relative to api_base)
            params: Query parameters
            resource_name: Name of resource for error messages

        Returns:
            JSON response data

        Raises:
            JiraAuthenticationError: If authentication fails
            JiraClientError: For other API errors
        """
        url = urljoin(self.api_base, endpoint)
        logging.debug(f"JIRA API request: {url}")
        if params:
            logging.debug(f"Query parameters: {params}")

        try:
            response = self.session.get(url, params=params or {}, timeout=30)
        except requests.exceptions.Timeout:
            raise JiraClientError(
                f"Request timed out while fetching {resource_name} from JIRA. "
                f"The JIRA server may be slow or unreachable."
            )
        except requests.exceptions.ConnectionError:
            raise JiraClientError(
                f"Connection failed while fetching {resource_name} from JIRA. "
                f"Please check your network connection and JIRA URL."
            )
        except requests.exceptions.RequestException as e:
            raise JiraClientError(
                f"Network error while fetching {resource_name} from JIRA: {e}"
            )

        logging.debug(f"Response status: {response.status_code}")

        # Handle error responses
        if response.status_code == 401:
            raise JiraAuthenticationError(
                "JIRA authentication failed. Please check your username and token."
            )
        if response.status_code == 403:
            raise JiraClientError(
                f"Access denied to {resource_name}. Check permissions or authentication."
            )
        if response.status_code == 404:
            raise JiraClientError(f"{resource_name} not found in JIRA.")
        if response.status_code != 200:
            raise JiraClientError(
                f"JIRA API request failed with status {response.status_code}. "
                f"Endpoint: {endpoint}. Response: {response.text[:200]}"
            )

        try:
            return response.json()
        except ValueError as e:
            raise JiraClientError(
                f"Invalid JSON response from JIRA API. The service may be experiencing issues. Details: {e}"
            )

    def test_connection(self) -> dict[str, Any]:
        """
        Test JIRA connection and authentication.

        Returns:
            User information if successful

        Raises:
            JiraAuthenticationError: If authentication fails
            JiraClientError: For other connection issues
        """
        return cast(
            dict[str, Any],
            self._make_request("myself", resource_name="User information"),
        )

    def get_issue(self, issue_key: str) -> dict[str, Any]:
        """
        Fetch a single JIRA issue with rank field.

        Args:
            issue_key: JIRA issue key (e.g., 'ANSTRAT-1660')

        Returns:
            Issue data including fields, type, and rank

        Raises:
            JiraClientError: If API request fails
        """
        # Discover rank field if not already known
        if self._rank_field_id is None:
            self._rank_field_id = self._discover_rank_field()

        # Request issue with rank field
        fields = ["key", "summary", "status", "issuetype", "priority"]
        if self._rank_field_id:
            fields.append(self._rank_field_id)

        endpoint = f"issue/{issue_key}"
        params = {"fields": ",".join(fields)}

        issue_data = cast(
            dict[str, Any],
            self._make_request(
                endpoint, params=params, resource_name=f"Issue {issue_key}"
            ),
        )

        # Enrich with rank field ID for easier access
        if self._rank_field_id:
            issue_data["_rank_field_id"] = self._rank_field_id

        return issue_data

    def _discover_rank_field(self) -> str | None:
        """
        Discover the ID of the Rank field by querying field metadata.

        Returns:
            Field ID for the Rank field, or None if not found
        """
        try:
            fields = self._make_request("field", resource_name="field metadata")

            # Look for the Rank field
            for field in fields:
                field_name = field.get("name", "").lower()
                field_id = field.get("id")
                schema = field.get("schema", {})
                custom_type = schema.get("custom", "")

                # Skip obsolete fields
                if (
                    "obsolete" in field_name
                    or "(obsolete)" in field.get("name", "").lower()
                ):
                    logging.debug(
                        f"Skipping obsolete Rank field: {field_id} ({field.get('name')})"
                    )
                    continue

                # Check if this is the Rank field by name or custom type
                if (
                    field_name == "rank"
                    or "rank" in custom_type.lower()
                    or custom_type == "com.pyxis.greenhopper.jira:gh-lexo-rank"
                ):
                    logging.info(
                        f"Discovered JIRA Rank field: {field_id} ({field.get('name')})"
                    )
                    return cast(str, field_id) if field_id else None

            logging.warning(
                "Rank field not found in JIRA instance. Rank information will not be available."
            )
            return None

        except Exception as e:
            logging.warning(f"Failed to discover JIRA Rank field: {e}")
            return None

    def get_issues_metadata(self, issue_keys: list[str]) -> dict[str, dict[str, Any]]:
        """
        Fetch metadata for multiple issues efficiently.

        Args:
            issue_keys: List of JIRA issue keys

        Returns:
            Dictionary mapping issue keys to their metadata

        Raises:
            JiraClientError: If API request fails
        """
        if not issue_keys:
            return {}

        metadata = {}
        for issue_key in issue_keys:
            try:
                issue_data = self.get_issue(issue_key)
                metadata[issue_key] = issue_data
                logging.debug(f"Fetched metadata for {issue_key}")
            except JiraClientError as e:
                logging.warning(f"Failed to fetch metadata for {issue_key}: {e}")
                # Continue with other issues
                continue

        return metadata

    def extract_rank_value(self, issue_data: dict[str, Any]) -> str | None:
        """
        Extract the rank value from issue data.

        Args:
            issue_data: Issue data from get_issue()

        Returns:
            Rank value as string, or None if not available
        """
        rank_field_id = issue_data.get("_rank_field_id")
        if not rank_field_id:
            return None

        fields = issue_data.get("fields", {})
        rank_value = fields.get(rank_field_id)
        return cast(str, rank_value) if rank_value is not None else None

    def get_issue_type(self, issue_data: dict[str, Any]) -> str | None:
        """
        Extract the issue type from issue data.

        Args:
            issue_data: Issue data from get_issue()

        Returns:
            Issue type name (e.g., 'Feature', 'Initiative'), or None
        """
        fields = issue_data.get("fields", {})
        issue_type = fields.get("issuetype", {})
        name = issue_type.get("name")
        return cast(str, name) if name is not None else None

    def get_issue_status(self, issue_data: dict[str, Any]) -> str | None:
        """
        Extract the issue status from issue data.

        Args:
            issue_data: Issue data from get_issue()

        Returns:
            Issue status name (e.g., 'New', 'Backlog', 'In Progress'), or None
        """
        fields = issue_data.get("fields", {})
        status = fields.get("status", {})
        name = status.get("name")
        return cast(str, name) if name is not None else None
